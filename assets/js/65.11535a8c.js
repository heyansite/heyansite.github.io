(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{602:function(s,t){s.exports="data:image/png;base64,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"},603:function(s,t,n){s.exports=n.p+"assets/img/lock-02.7e0e1b0d.jpg"},808:function(s,t,n){"use strict";n.r(t);var a=n(0),e=Object(a.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"_0-各种锁及java实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-各种锁及java实现"}},[s._v("#")]),s._v(" 0 - 各种锁及Java实现")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("转")]),s._v(" "),a("p",[a("font",{attrs:{color:"orange"}},[a("strong",[s._v("理解文章1")]),s._v("（"),a("em",[s._v("仅供参考，待深入理解")]),s._v("）")])],1),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/71156910",target:"_self",rel:"noopener noreferrer"}},[s._v("通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现！")])])])]),s._v(" "),a("p",[s._v("网上关于Java中锁的话题可以说资料相当丰富，但相关内容总感觉是一大串术语的罗列，让人云里雾里，读完就忘。本文希望能为Java新人做一篇通俗易懂的整合，旨在消除对各种各样锁的术语的恐惧感，对每种锁的底层实现浅尝辄止，但是在需要时能够知道去查什么。")]),s._v(" "),a("p",[s._v("首先要打消一种想法，就是一个锁只能属于一种分类。其实并不是这样，比如一个锁可以同时是悲观锁、可重入锁、公平锁、可中断锁等等，就像一个人可以是男人、医生、健身爱好者、游戏玩家，这并不矛盾。OK，国际惯例，上干货。")]),s._v(" "),a("h2",{attrs:{id:"synchronized与lock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized与lock"}},[s._v("#")]),s._v(" synchronized与Lock")]),s._v(" "),a("p",[s._v("Java中有两种加锁的方式：一种是用"),a("strong",[s._v("synchronized关键字")]),s._v("，另一种是用"),a("strong",[s._v("Lock接口")]),s._v("的实现类。")]),s._v(" "),a("p",[s._v("形象地说，synchronized关键字是"),a("strong",[s._v("自动档")]),s._v("，可以满足一切日常驾驶需求。但是如果你想要玩漂移或者各种骚操作，就需要"),a("strong",[s._v("手动档")]),s._v("了——各种Lock的实现类。")]),s._v(" "),a("p",[s._v("所以如果你只是想要简单的加个锁，对性能也没什么特别的要求，用synchronized关键字就足够了。自Java 5之后，才在java.util.concurrent.locks包下有了另外一种方式来实现锁，那就是Lock。也就是说**，synchronized是Java语言内置的关键字，而Lock是一个接口**，这个接口的实现类在代码层面实现了锁的功能，具体细节不在本文展开，有兴趣可以研究下AbstractQueuedSynchronizer类，写得可以说是牛逼爆了。")]),s._v(" "),a("div",{staticStyle:{display:"flex"}},[a("img",{staticStyle:{display:"block"},attrs:{src:n(602),alt:"",align:"left"}})]),s._v(" "),a("blockquote",[a("p",[s._v("其实只需要关注三个类就可以了：ReentrantLock类、ReadLock类、WriteLock类。")])]),s._v(" "),a("p",[a("strong",[s._v("ReentrantLock、ReadLock、WriteLock")]),s._v(" 是Lock接口最重要的三个实现类。对应了“可重入锁”、“读锁”和“写锁”，后面会讲它们的用途。")]),s._v(" "),a("p",[s._v("ReadWriteLock其实是一个工厂接口，而ReentrantReadWriteLock是ReadWriteLock的实现类，它包含两个静态内部类ReadLock和WriteLock。这两个静态内部类又分别实现了Lock接口。")]),s._v(" "),a("p",[s._v("我们停止深究源码，仅从使用的角度看，Lock与synchronized的区别是什么？在接下来的几个小节中，我将梳理各种锁分类的概念，以及synchronized关键字、各种Lock实现类之间的区别与联系。")]),s._v(" "),a("h2",{attrs:{id:"悲观锁与乐观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁与乐观锁"}},[s._v("#")]),s._v(" 悲观锁与乐观锁")]),s._v(" "),a("p",[s._v("锁的一种宏观分类方式是"),a("strong",[s._v("悲观锁")]),s._v("和"),a("strong",[s._v("乐观锁")]),s._v("。悲观锁与乐观锁"),a("strong",[s._v("并不是特指某个锁")]),s._v("（Java中没有哪个Lock实现类就叫PessimisticLock或OptimisticLock），而是在并发情况下的两种不同策略。")]),s._v(" "),a("p",[s._v("悲观锁（Pessimistic Lock）, 就是很悲观，每次去拿数据的时候都认为别人会修改。所以每次在拿数据的时候都会上锁。这样别人想拿数据就被挡住，直到悲观锁被释放。")]),s._v(" "),a("p",[s._v("乐观锁（Optimistic Lock）, 就是很乐观，每次去拿数据的时候都认为别人不会修改。所以"),a("strong",[s._v("不会上锁，不会上锁！"),a("strong",[s._v("但是如果想要更新数据，则会在")]),s._v("更新前检查在读取至更新这段时间别人有没有修改过这个数据")]),s._v("。如果修改过，则重新读取，再次尝试更新，循环上述步骤直到更新成功（当然也允许更新失败的线程放弃操作）。")]),s._v(" "),a("p",[a("strong",[s._v("悲观锁阻塞事务，乐观锁回滚重试")]),s._v("，它们各有优缺点，不要认为一种一定好于另一种。像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行重试，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。")]),s._v(" "),a("h2",{attrs:{id:"乐观锁的基础——cas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁的基础——cas"}},[s._v("#")]),s._v(" 乐观锁的基础——CAS")]),s._v(" "),a("p",[s._v("说到乐观锁，就必须提到一个概念："),a("strong",[s._v("CAS")])]),s._v(" "),a("p",[s._v("什么是CAS呢？Compare-and-Swap，即"),a("strong",[s._v("比较并替换")]),s._v("，也有叫做Compare-and-Set的**，比较并设置**。")]),s._v(" "),a("ol",[a("li",[s._v("比较：读取到了一个值A，在将其更新为B之前，检查原值是否仍为A（未被其他线程改动）。")]),s._v(" "),a("li",[s._v("设置：如果是，将A更新为B，结束。["),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/71156910#ref_1",target:"_self",rel:"noopener noreferrer"}},[s._v("1]")]),s._v("如果不是，则什么都不做。")])]),s._v(" "),a("p",[s._v("上面的两步操作是原子性的，可以简单地理解为瞬间完成，在CPU看来就是一步操作。")]),s._v(" "),a("p",[s._v("有了CAS，就可以实现一个"),a("strong",[s._v("乐观锁")]),s._v("：")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[s._v("data "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("123")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 共享数据")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* 更新数据的线程会进行如下操作 */")]),s._v("\nflag "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("while")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("flag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    oldValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" data"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 保存原始数据")]),s._v("\n    newValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("doSomething")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("oldValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" \n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 下面的部分为CAS操作，尝试更新data的值")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("data "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" oldValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 比较")]),s._v("\n        data "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" newValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 设置")]),s._v("\n        flag "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 结束")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 啥也不干，循环重试")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* \n   很明显，这样的代码根本不是原子性的，\n   因为真正的CAS利用了CPU指令，\n   这里只是为了展示执行流程，本意是一样的。\n*/")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br")])]),a("p",[s._v("这是一个简单直观的乐观锁实现，它允许多个线程同时读取（因为根本没有加锁操作），但是只有一个线程可以成功更新数据，并导致其他要更新数据的线程回滚重试。 CAS利用CPU指令，从硬件层面保证了操作的原子性，以达到类似于锁的效果。")]),s._v(" "),a("div",{staticStyle:{display:"flex"}},[a("img",{staticStyle:{display:"block"},attrs:{src:n(603),alt:"",align:"left"}})]),s._v(" "),a("blockquote",[a("p",[s._v("Java中真正的CAS操作调用的native方法")])]),s._v(" "),a("p",[s._v("因为整个过程中并没有“加锁”和“解锁”操作，因此乐观锁策略也被称为"),a("strong",[s._v("无锁编程")]),s._v("。换句话说，乐观锁其实不是“锁”，它仅仅是一个循环重试CAS的算法而已！")]),s._v(" "),a("h2",{attrs:{id:"自旋锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁"}},[s._v("#")]),s._v(" 自旋锁")]),s._v(" "),a("p",[s._v("有一种锁叫"),a("strong",[s._v("自旋锁")]),s._v("。所谓自旋，说白了就是一个 while(true) 无限循环。"),a("br"),s._v("刚刚的乐观锁就有类似的无限循环操作，那么它是自旋锁吗？"),a("br"),s._v("不是。尽管自旋与 while(true) 的操作是一样的，但还是应该将这两个术语分开。“自旋”这两个字，特指自旋锁的自旋。"),a("br"),s._v("然而在JDK中并没有自旋锁（SpinLock）这个类，那什么才是自旋锁呢？读完下个小节就知道了。")]),s._v(" "),a("h2",{attrs:{id:"synchronized锁升级：偏向锁-→-轻量级锁-→-重量级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized锁升级：偏向锁-→-轻量级锁-→-重量级锁"}},[s._v("#")]),s._v(" synchronized锁升级：偏向锁 → 轻量级锁 → 重量级锁")]),s._v(" "),a("p",[s._v("前面提到，synchronized关键字就像是汽车的"),a("strong",[s._v("自动档")]),s._v("，现在详细讲这个过程。一脚油门踩下去，synchronized会从"),a("strong",[s._v("无锁")]),s._v("升级为"),a("strong",[s._v("偏向锁")]),s._v("，再升级为"),a("strong",[s._v("轻量级锁")]),s._v("，最后升级为"),a("strong",[s._v("重量级锁")]),s._v("，就像自动换挡一样。那么自旋锁在哪里呢？这里的轻量级锁就是一种"),a("strong",[s._v("自旋锁")]),s._v("。")]),s._v(" "),a("p",[s._v("初次执行到synchronized代码块的时候，锁对象变成"),a("strong",[s._v("偏向锁")]),s._v("（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并"),a("strong",[s._v("不会主动释放偏向锁")]),s._v("。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行**。由于之前没有释放锁，这里也就不需要重新加锁**。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。")]),s._v(" "),a("p",[s._v("一旦有第二个线程加入"),a("strong",[s._v("锁竞争")]),s._v("，偏向锁就升级为"),a("strong",[s._v("轻量级锁（自旋锁）")]),s._v("。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。")]),s._v(" "),a("p",[s._v("在轻量级锁状态下继续锁竞争，没有抢到锁的线程将"),a("strong",[s._v("自旋")]),s._v("，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先"),a("strong",[s._v("比较")]),s._v("当前锁标志位是否为“释放”，如果是则将其"),a("strong",[s._v("设置")]),s._v("为“锁定”，比较并设置是"),a("strong",[s._v("原子性")]),s._v("发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。")]),s._v(" "),a("p",[s._v("长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做"),a("strong",[s._v("忙等（busy-waiting）")]),s._v("。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法**，短时间的忙等，换取线程在用户态和内核态之间切换的开销**。")]),s._v(" "),a("p",[s._v("显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为"),a("strong",[s._v("重量级锁")]),s._v("（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。")]),s._v(" "),a("p",[s._v("一个锁只能按照 偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有叫"),a("strong",[s._v("锁膨胀")]),s._v("的），不允许降级。")]),s._v(" "),a("blockquote",[a("p",[s._v("偏向锁的一个特性是，持有锁的线程在执行完同步代码块时不会释放锁。那么当第二个线程执行到这个synchronized代码块时是否一定会发生锁竞争然后升级为轻量级锁呢？\n线程A第一次执行完同步代码块后，当线程B尝试获取锁的时候，发现是偏向锁，会判断线程A是否仍然存活**。如果线程A仍然存活**，将线程A暂停，此时偏向锁升级为轻量级锁，之后线程A继续执行，线程B自旋。但是"),a("strong",[s._v("如果判断结果是线程A不存在了")]),s._v("，则线程B持有此偏向锁，锁不升级。\n还有人对此有疑惑，我之前确实没有描述清楚，但如果要展开讲，涉及到太多新概念，可以新开一篇了。更何况有些太底层的东西，我没读过源码，没有自信说自己一定是对的。其实在升级为轻量级锁之前，虚拟机会让线程A尽快在安全点挂起，然后在它的栈中“伪造”一些信息，让线程A在被唤醒之后，认为自己一直持有的是轻量级锁。如果线程A之前正在同步代码块中，那么线程B自旋等待即可。如果线程A之前不在同步代码块中，它会在被唤醒后检查到这一情况并立即释放锁，让线程B可以拿到。这部分内容我之前也没有深入研究过，如果有说的不对的，请多多指教啊！")])]),s._v(" "),a("h2",{attrs:{id:"可重入锁（递归锁）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可重入锁（递归锁）"}},[s._v("#")]),s._v(" 可重入锁（递归锁）")]),s._v(" "),a("p",[s._v("可重入锁的字面意思是“可以重新进入的锁”，即"),a("strong",[s._v("允许同一个线程多次获取同一把锁")]),s._v("。比如一个递归函数里有加锁操作，递归过程中这个锁会阻塞自己吗？如果不会，那么这个锁就是"),a("strong",[s._v("可重入锁")]),s._v("（因为这个原因可重入锁也叫做"),a("strong",[s._v("递归锁")]),s._v("）****。")]),s._v(" "),a("p",[s._v("Java里只要以Reentrant开头命名的锁都是可重入锁，而且"),a("strong",[s._v("JDK提供的所有现成的Lock实现类，包括synchronized关键字锁都是可重入的")]),s._v("。如果你需要不可重入锁，只能自己去实现了。网上不可重入锁的实现真的很多，就不在这里贴代码了。99%的业务场景用可重入锁就可以了，剩下的1%是什么呢？我也不知道，谁可以在评论里告诉我？")]),s._v(" "),a("h2",{attrs:{id:"公平锁、非公平锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#公平锁、非公平锁"}},[s._v("#")]),s._v(" 公平锁、非公平锁")]),s._v(" "),a("p",[s._v("如果多个线程申请一把"),a("strong",[s._v("公平锁")]),s._v("，那么当锁释放的时候，先申请的先得到，非常公平。显然如果是"),a("strong",[s._v("非公平锁")]),s._v("，后申请的线程可能先获取到锁，是随机或者按照其他优先级排序的。")]),s._v(" "),a("p",[s._v("对ReentrantLock类而言，通过构造函数传参"),a("strong",[s._v("可以指定该锁是否是公平锁，默认是非公平锁")]),s._v("。一般情况下，非公平锁的吞吐量比公平锁大，如果没有特殊要求，优先使用非公平锁。")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n* Creates an instance of {@code ReentrantLock} with the\n* given fairness policy.\n*\n* @param fair {@code true} if this lock should use a fair ordering policy\n*/")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ReentrantLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("boolean")]),s._v(" fair"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  \tsync "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" fair "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("FairSync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("NonfairSync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("blockquote",[a("p",[s._v("ReentrantLock构造器可以指定为公平或非公平")])]),s._v(" "),a("p",[s._v("对于synchronized而言，它也是一种"),a("strong",[s._v("非公平锁")]),s._v("，但是并没有任何办法使其变成公平锁。")]),s._v(" "),a("h2",{attrs:{id:"可中断锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可中断锁"}},[s._v("#")]),s._v(" 可中断锁")]),s._v(" "),a("p",[s._v("可中断锁，字面意思是“可以"),a("strong",[s._v("响应中断")]),s._v("的锁”。")]),s._v(" "),a("p",[s._v("这里的关键是理解什么是"),a("strong",[s._v("中断")]),s._v("。Java并没有提供任何直接中断某线程的方法，只提供了"),a("strong",[s._v("中断机制")]),s._v("。何谓“中断机制”？线程A向线程B发出“请你停止运行”的请求（线程B也可以自己给自己发送此请求），但线程B并不会立刻停止运行，而是自行选择合适的时机以自己的方式响应中断，也可以直接忽略此中断。也就是说，Java的"),a("strong",[s._v("中断不能直接终止线程")]),s._v("，而是需要被中断的线程自己决定怎么处理。这好比是父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己。")]),s._v(" "),a("p",[s._v("回到锁的话题上来，如果线程A持有锁，线程B等待获取该锁。由于线程A持有锁的时间过长，线程B不想继续等待了，我们可以让线程B中断自己或者在别的线程里中断它，这种就是"),a("strong",[s._v("可中断锁")]),s._v("。")]),s._v(" "),a("p",[s._v("在Java中，synchronized就是"),a("strong",[s._v("不可中断锁")]),s._v("，而Lock的实现类都是"),a("strong",[s._v("可中断锁")]),s._v("，可以简单看下Lock接口。")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/* Lock接口 */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("interface")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Lock")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("lock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 拿不到锁就一直等，拿到马上返回。")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("lockInterruptibly")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("InterruptedException")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 拿不到锁就一直等，如果等待时收到中断请求，则需要处理InterruptedException。")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("boolean")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("tryLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 无论拿不拿得到锁，都马上返回。拿到返回true，拿不到返回false。")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("boolean")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("tryLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("long")]),s._v(" time"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("TimeUnit")]),s._v(" unit"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("InterruptedException")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 同上，可以自定义等待的时间。")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("unlock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Condition")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("newCondition")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("h2",{attrs:{id:"读写锁、共享锁、互斥锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#读写锁、共享锁、互斥锁"}},[s._v("#")]),s._v(" 读写锁、共享锁、互斥锁")]),s._v(" "),a("p",[s._v("读写锁其实是一对锁，一个读锁（共享锁）和一个写锁（互斥锁、排他锁）。")]),s._v(" "),a("p",[s._v("看下Java里的ReadWriteLock接口，它只规定了两个方法，一个返回读锁，一个返回写锁。")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("interface")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("ReadWriteLock")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n  \t* Returns the lock used for reading.\n  \t*\n  \t* @return the lock used for reading\n  \t*/")]),s._v("\n  \t"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Lock")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("readLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  \n  \t"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n  \t* Returns the lock used for writing.\n  \t*\n  \t* @return the lock used for writing\n  \t*/")]),s._v("\n  \t"),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Lock")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("writeLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br")])]),a("p",[s._v("记得之前的乐观锁策略吗？所有线程随时都可以读，仅在写之前判断值有没有被更改。")]),s._v(" "),a("p",[s._v("读写锁其实做的事情是一样的，但是策略稍有不同。很多情况下，线程知道自己读取数据后，是否是为了更新它。那么何不在加锁的时候直接明确这一点呢？如果我读取值是为了更新它（SQL的for update就是这个意思），那么加锁的时候就直接加"),a("strong",[s._v("写锁")]),s._v("，我持有写锁的时候别的线程无论读还是写都需要等待；如果我读取数据仅为了前端展示，那么加锁时就明确地加一个"),a("strong",[s._v("读锁")]),s._v("，其他线程如果也要加读锁，不需要等待，可以直接获取（读锁计数器+1）。")]),s._v(" "),a("p",[s._v("虽然读写锁感觉与乐观锁有点像，但是"),a("strong",[s._v("读写锁是悲观锁策略")]),s._v("。因为读写锁并没有在"),a("strong",[s._v("更新前")]),s._v("判断值有没有被修改过，而是在"),a("strong",[s._v("加锁前")]),s._v("决定应该用读锁还是写锁。乐观锁特指无锁编程，如果仍有疑惑可以再回到第一、二小节，看一下什么是“乐观锁”。")]),s._v(" "),a("p",[s._v("JDK提供的唯一一个ReadWriteLock接口实现类是ReentrantReadWriteLock。看名字就知道，它不仅提供了读写锁，而是都是可重入锁。 除了两个接口方法以外，ReentrantReadWriteLock还提供了一些便于外界监控其内部工作状态的方法，这里就不一一展开。")]),s._v(" "),a("h2",{attrs:{id:"回到悲观锁和乐观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回到悲观锁和乐观锁"}},[s._v("#")]),s._v(" 回到悲观锁和乐观锁")]),s._v(" "),a("blockquote",[a("p",[s._v("这篇文章经历过一次修改，我之前认为偏向锁和轻量级锁是乐观锁，重量级锁和Lock实现类为悲观锁，网上很多资料对这些概念的表述也很模糊，各执一词。")])]),s._v(" "),a("p",[s._v("先抛出我的结论：")]),s._v(" "),a("p",[s._v("我们在Java里使用的各种锁**，几乎全都是悲观锁**。synchronized从偏向锁、轻量级锁到重量级锁，全是悲观锁。JDK提供的Lock实现类全是悲观锁。其实只要有“锁对象”出现，那么就一定是悲观锁。因为"),a("strong",[s._v("乐观锁不是锁，而是一个在循环里尝试CAS的算法")]),s._v("。")]),s._v(" "),a("p",[s._v("那JDK并发包里到底有没有乐观锁呢？"),a("br"),s._v("有。java.util.concurrent.atomic包里面的"),a("strong",[s._v("原子类")]),s._v("都是利用乐观锁实现的。")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("getAndIncrement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  \t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n      \t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" current "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n      \t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" next "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" current "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n      \t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("compareAndSet")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("current"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" next"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n          \t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" current"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("blockquote",[a("p",[s._v("原子类AtomicInteger的自增方法为乐观锁策略")])]),s._v(" "),a("p",[s._v("为什么网上有些资料认为偏向锁、轻量级锁是乐观锁？理由是它们底层用到了CAS？或者是把“乐观/悲观”与“轻量/重量”搞混了？其实，线程在抢占这些锁的时候，确实是循环+CAS的操作，感觉好像是乐观锁。但问题的关键是，我们说一个锁是悲观锁还是乐观锁，总是应该站在应用层，看它们是如何锁住应用数据的，而不是站在底层看抢占锁的过程。如果一个线程尝试获取锁时，发现已经被占用，它是否继续读取数据，等后续要更新时再决定要不要重试？对于偏向锁、轻量级锁来说，显然答案是否定的。无论是挂起还是忙等，对应用数据的读取操作都被“挡住”了。从这个角度看，它们确实是悲观锁。")])])}),[],!1,null,null,null);t.default=e.exports}}]);